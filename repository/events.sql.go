// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: events.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO "Event" (
  "title",
  "description",
  "place",
  "coordinates",
  "starts_at",
  "ends_at",
  "capacity",
  "user_creator_id",
  "group_creator_id"
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at
`

type CreateEventParams struct {
	Title          pgtype.Text
	Description    pgtype.Text
	Place          pgtype.Text
	Coordinates    pgtype.Point
	StartsAt       pgtype.Timestamp
	EndsAt         pgtype.Timestamp
	Capacity       pgtype.Int4
	UserCreatorID  pgtype.UUID
	GroupCreatorID pgtype.UUID
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.Place,
		arg.Coordinates,
		arg.StartsAt,
		arg.EndsAt,
		arg.Capacity,
		arg.UserCreatorID,
		arg.GroupCreatorID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Place,
		&i.Coordinates,
		&i.StartsAt,
		&i.EndsAt,
		&i.Capacity,
		&i.UserCreatorID,
		&i.GroupCreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEventById = `-- name: GetEventById :one
SELECT id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at FROM "Event"
WHERE "id" = $1
  AND "deleted_at" IS NULL
`

func (q *Queries) GetEventById(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Place,
		&i.Coordinates,
		&i.StartsAt,
		&i.EndsAt,
		&i.Capacity,
		&i.UserCreatorID,
		&i.GroupCreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many
SELECT id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at FROM "Event" 
ORDER BY "starts_at"
  AND "deleted_at" IS NULL
`

func (q *Queries) GetEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Place,
			&i.Coordinates,
			&i.StartsAt,
			&i.EndsAt,
			&i.Capacity,
			&i.UserCreatorID,
			&i.GroupCreatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByCreator = `-- name: GetEventsByCreator :many
SELECT id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at FROM "Event"
WHERE "user_creator_id" = $1
  AND "deleted_at" IS NULL
`

func (q *Queries) GetEventsByCreator(ctx context.Context, userCreatorID pgtype.UUID) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByCreator, userCreatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Place,
			&i.Coordinates,
			&i.StartsAt,
			&i.EndsAt,
			&i.Capacity,
			&i.UserCreatorID,
			&i.GroupCreatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByGroup = `-- name: GetEventsByGroup :many
SELECT id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at FROM "Event"
WHERE "group_creator_id" = $1
  AND "deleted_at" IS NULL
`

func (q *Queries) GetEventsByGroup(ctx context.Context, groupCreatorID pgtype.UUID) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByGroup, groupCreatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Place,
			&i.Coordinates,
			&i.StartsAt,
			&i.EndsAt,
			&i.Capacity,
			&i.UserCreatorID,
			&i.GroupCreatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsStartedInRange = `-- name: GetEventsStartedInRange :many
SELECT id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at FROM "Event"
WHERE "starts_at" BETWEEN $1 AND $2
AND "deleted_at" IS NULL
`

type GetEventsStartedInRangeParams struct {
	StartsAt   pgtype.Timestamp
	StartsAt_2 pgtype.Timestamp
}

func (q *Queries) GetEventsStartedInRange(ctx context.Context, arg GetEventsStartedInRangeParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsStartedInRange, arg.StartsAt, arg.StartsAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Place,
			&i.Coordinates,
			&i.StartsAt,
			&i.EndsAt,
			&i.Capacity,
			&i.UserCreatorID,
			&i.GroupCreatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const modifyEvent = `-- name: ModifyEvent :one
UPDATE "Event"
SET 
    "title" = COALESCE($2, "title"),
    "description" = COALESCE($3, "description"),
    "place" = COALESCE($4, "place"),
    "coordinates" = COALESCE($5, "coordinates"),
    "starts_at" = COALESCE($6, "starts_at"),
    "ends_at" = COALESCE($7, "ends_at"),
    "capacity" = COALESCE($8, "capacity")
WHERE "id" = $1
RETURNING id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at
`

type ModifyEventParams struct {
	ID          pgtype.UUID
	Title       pgtype.Text
	Description pgtype.Text
	Place       pgtype.Text
	Coordinates pgtype.Point
	StartsAt    pgtype.Timestamp
	EndsAt      pgtype.Timestamp
	Capacity    pgtype.Int4
}

func (q *Queries) ModifyEvent(ctx context.Context, arg ModifyEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, modifyEvent,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Place,
		arg.Coordinates,
		arg.StartsAt,
		arg.EndsAt,
		arg.Capacity,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Place,
		&i.Coordinates,
		&i.StartsAt,
		&i.EndsAt,
		&i.Capacity,
		&i.UserCreatorID,
		&i.GroupCreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteEvent = `-- name: SoftDeleteEvent :one
UPDATE "Event"
SET "deleted_at" = NOW()
WHERE "id" = $1
RETURNING id, title, description, place, coordinates, starts_at, ends_at, capacity, user_creator_id, group_creator_id, created_at, updated_at, deleted_at
`

func (q *Queries) SoftDeleteEvent(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, softDeleteEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Place,
		&i.Coordinates,
		&i.StartsAt,
		&i.EndsAt,
		&i.Capacity,
		&i.UserCreatorID,
		&i.GroupCreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
